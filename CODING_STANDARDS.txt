================================================================================
  INFYNIQ SERVICE - PADR√ïES DE CODIFICA√á√ÉO
================================================================================

üìã GUIA R√ÅPIDO DE PADR√ïES PARA O PROJETO

================================================================================
1. ESTRUTURA DE PASTAS
================================================================================

Cada m√≥dulo em sua pr√≥pria pasta:
  modules/[nome-modulo]/
  ‚îú‚îÄ‚îÄ [nome].module.ts
  ‚îú‚îÄ‚îÄ [nome].controller.ts
  ‚îú‚îÄ‚îÄ [nome].service.ts
  ‚îú‚îÄ‚îÄ dto/
  ‚îÇ   ‚îú‚îÄ‚îÄ create-[nome].dto.ts
  ‚îÇ   ‚îú‚îÄ‚îÄ update-[nome].dto.ts
  ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
  ‚îú‚îÄ‚îÄ entities/
  ‚îÇ   ‚îú‚îÄ‚îÄ [nome].entity.ts
  ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
  ‚îî‚îÄ‚îÄ repositories/
      ‚îî‚îÄ‚îÄ in-memory-[nome].repository.ts

Conven√ß√µes:
  - Pastas: kebab-case (exemplo: customer-service)
  - Arquivos: kebab-case.ts (exemplo: create-customer.dto.ts)
  - Diret√≥rios comuns: dto/, entities/, repositories/, services/

================================================================================
2. NOMENCLATURA
================================================================================

Classes/Interfaces:
  ‚úÖ CreateCustomerDto    (PascalCase)
  ‚úÖ UpdateCustomerDto
  ‚úÖ Customer
  ‚úÖ CustomerService
  ‚úÖ CustomersController
  ‚ùå create_customer_dto (snake_case)
  ‚ùå createCustomerDTO   (inconsistente)

Propriedades/M√©todos:
  ‚úÖ firstName           (camelCase)
  ‚úÖ getFullName()
  ‚úÖ isActive
  ‚ùå FirstName           (PascalCase)
  ‚ùå get_full_name()     (snake_case)

Arquivo/Pas:
  ‚úÖ create-customer.dto.ts    (kebab-case)
  ‚úÖ customer.entity.ts
  ‚úÖ customers.controller.ts
  ‚ùå CreateCustomer.dto.ts     (PascalCase)
  ‚ùå customer_entity.ts        (snake_case)

================================================================================
3. DTOs - VALIDA√á√ÉO COM CLASS-VALIDATOR
================================================================================

Sempre use decoradores @Is*, sempre complete as valida√ß√µes:

‚úÖ CORRETO:

  import { IsString, IsEmail, MinLength, IsOptional } from 'class-validator';

  export class CreateCustomerDto {
    @IsString()
    @MinLength(3, { message: 'Nome deve ter pelo menos 3 caracteres' })
    name: string;

    @IsEmail()
    email: string;

    @IsOptional()
    @IsString()
    phone?: string;
  }

‚ùå EVITAR:

  export class CreateCustomerDto {
    name: string;     // Sem valida√ß√£o
    email: string;
    phone?: string;
  }

================================================================================
4. ENTITIES - MODELOS DE DOM√çNIO
================================================================================

Sempre inclua auditoria:

‚úÖ CORRETO:

  export interface Customer {
    id: string;
    name: string;
    email: string;
    createdAt: Date;
    updatedAt: Date;
    updatedBy?: string;  // IMPORTANTE: auditoria
  }

‚ùå EVITAR:

  export interface Customer {
    id: string;
    name: string;
    email: string;
    // Sem createdAt/updatedAt
  }

================================================================================
5. SERVICES - L√ìGICA DE NEG√ìCIO
================================================================================

‚úÖ CORRETO:

  @Injectable()
  export class CustomerService {
    constructor(
      private readonly customerRepository: CustomerRepository,
      private readonly logger: LoggerService,
    ) {}

    async create(dto: CreateCustomerDto): Promise<Customer> {
      this.logger.log('Criando novo cliente: ' + dto.email);
      
      const customer = await this.customerRepository.create(dto);
      
      this.logger.log('Cliente criado: ' + customer.id);
      return customer;
    }

    async update(
      id: string,
      dto: UpdateCustomerDto,
      updatedBy: string = 'system',
    ): Promise<Customer> {
      this.logger.log(`Atualizando ${id} por ${updatedBy}`);
      return this.customerRepository.update(id, dto, updatedBy);
    }
  }

Regras:
  - Toda opera√ß√£o deve registrar com logger
  - Sempre passe updatedBy para reposit√≥rio
  - Nunca acesse diretamente fs ou console
  - Sempre validar regras de neg√≥cio antes de persistir

================================================================================
6. REPOSITORIES - PERSIST√äNCIA
================================================================================

‚úÖ CORRETO:

  @Injectable()
  export class InMemoryCustomerRepository {
    private customers: Customer[] = [];
    private readonly fileName = 'customers.json';

    constructor(private jsonDbService: JsonDbService) {
      this.loadFromFile();
    }

    async create(data: CreateCustomerDto): Promise<Customer> {
      const customer: Customer = {
        id: uuid(),
        ...data,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      
      this.customers.push(customer);
      await this.saveToFile();
      return customer;
    }

    async update(
      id: string,
      data: Partial<Customer>,
      updatedBy: string = 'system',
    ): Promise<Customer> {
      const index = this.customers.findIndex(c => c.id === id);
      if (index === -1) throw new Error('N√£o encontrado');

      this.customers[index] = {
        ...this.customers[index],
        ...data,
        updatedAt: new Date(),
        updatedBy,  // IMPORTANTE: auditoria
      };

      await this.saveToFile();
      return this.customers[index];
    }

    private async saveToFile(): Promise<void> {
      await this.jsonDbService.writeFile(this.fileName, this.customers);
    }
  }

Regras:
  - ‚úÖ Use JsonDbService para I/O
  - ‚úÖ Sempre salve updatedAt e updatedBy
  - ‚ùå Nunca use fs direto
  - ‚ùå Nunca use console.log

================================================================================
7. CONTROLLERS - ENDPOINTS REST
================================================================================

‚úÖ CORRETO:

  @Controller('customers')
  export class CustomersController {
    constructor(private readonly customerService: CustomerService) {}

    @Post()
    @HttpCode(201)
    create(@Body() dto: CreateCustomerDto) {
      return this.customerService.create(dto);
    }

    @Get()
    findAll() {
      return this.customerService.findAll();
    }

    @Get(':id')
    findOne(@Param('id') id: string) {
      return this.customerService.findById(id);
    }

    @Patch(':id')
    update(
      @Param('id') id: string,
      @Body() dto: UpdateCustomerDto,
    ) {
      return this.customerService.update(id, dto, 'system');
    }

    @Delete(':id')
    @HttpCode(204)
    delete(@Param('id') id: string) {
      return this.customerService.delete(id);
    }
  }

Padr√£o de Endpoints:
  POST   /customers          ‚Üí create()
  GET    /customers          ‚Üí findAll()
  GET    /customers/:id      ‚Üí findOne()
  PATCH  /customers/:id      ‚Üí update()
  DELETE /customers/:id      ‚Üí delete()

Regras:
  - ‚úÖ DTOs validam input automaticamente
  - ‚úÖ Delegue l√≥gica para Service
  - ‚úÖ Use @HttpCode para status apropriado
  - ‚ùå Nunca implemente l√≥gica no Controller

================================================================================
8. LOGGING
================================================================================

‚úÖ SEMPRE USE LoggerService:

  constructor(private logger: LoggerService) {}

  async create(dto: CreateCustomerDto): Promise<Customer> {
    this.logger.log('Criando cliente...');
    // ... l√≥gica
    this.logger.log('Cliente criado com sucesso');
    return customer;
  }

‚ùå NUNCA USE:

  console.log('Criando cliente...');
  console.error('Erro ao criar');

================================================================================
9. VALIDA√á√ïES
================================================================================

3 CAMADAS DE VALIDA√á√ÉO:

1. DTO (Sintaxe)
   @IsString()
   @MinLength(3)
   name: string;

2. Service (Regra de Neg√≥cio)
   if (existingCustomer) {
     throw new ConflictException('Email j√° existe');
   }

3. Repository (Integridade)
   if (index === -1) {
     throw new Error('N√£o encontrado');
   }

================================================================================
10. AUDITORIA
================================================================================

SEMPRE INCLUIR EM ENTITIES:
  - createdAt: Date
  - updatedAt: Date
  - updatedBy?: string ('system' por padr√£o)

SEMPRE ATUALIZAR EM UPDATES:
  updatedAt: new Date()
  updatedBy: updatedBy  // Passado como par√¢metro

EXEMPLO:
  async update(
    id: string,
    data: Partial<Entity>,
    updatedBy: string = 'system',  ‚Üê Par√¢metro obrigat√≥rio
  ): Promise<Entity> {
    entity.updatedAt = new Date();
    entity.updatedBy = updatedBy;   ‚Üê Sempre persistir
    return entity;
  }

================================================================================
11. TRATAMENTO DE ERROS
================================================================================

‚úÖ CORRETO:

  import { NotFoundException } from '@nestjs/common';

  try {
    const customer = await this.repo.findById(id);
    if (!customer) {
      throw new NotFoundException('Cliente n√£o encontrado');
    }
  } catch (error) {
    this.logger.error('Erro ao buscar cliente', error);
    throw error;
  }

‚ùå EVITAR:

  if (!customer) console.log('not found');
  throw new Error('Erro gen√©rico');

================================================================================
12. ESTRUTURA DE M√ìDULO COMPLETA
================================================================================

Exemplo: Module = Customers

customers.module.ts:
  @Module({
    imports: [DatabaseModule],
    controllers: [CustomersController],
    providers: [CustomersService, InMemoryCustomerRepository],
    exports: [CustomersService],
  })
  export class CustomersModule {}

customers.controller.ts:
  @Controller('customers')
  export class CustomersController {
    constructor(private service: CustomersService) {}
    // endpoints
  }

customers.service.ts:
  @Injectable()
  export class CustomersService {
    constructor(
      private repo: InMemoryCustomerRepository,
      private logger: LoggerService,
    ) {}
    // l√≥gica de neg√≥cio
  }

repositories/in-memory-customer.repository.ts:
  @Injectable()
  export class InMemoryCustomerRepository {
    constructor(private jsonDbService: JsonDbService) {}
    // persist√™ncia
  }

entities/customer.entity.ts:
  export interface Customer { ... }

dto/create-customer.dto.ts:
  export class CreateCustomerDto { ... }

dto/update-customer.dto.ts:
  export class UpdateCustomerDto { ... }

================================================================================
13. IMPORTS & EXPORTS
================================================================================

‚úÖ USE index.ts COMO BARREL EXPORT:

  // modules/customers/index.ts
  export * from './customers.module';
  export * from './dto';
  export * from './entities';

  // modules/customers/dto/index.ts
  export { CreateCustomerDto } from './create-customer.dto';
  export { UpdateCustomerDto } from './update-customer.dto';

  // Uso:
  import { CustomersModule, CreateCustomerDto } from './modules/customers';

================================================================================
14. CHECKLIST ANTES DE COMMITAR
================================================================================

‚ñ° Arquivo segue nomenclatura (kebab-case)
‚ñ° Classes em PascalCase, propriedades em camelCase
‚ñ° DTOs com @Is* decoradores completos
‚ñ° Entities com createdAt, updatedAt, updatedBy
‚ñ° Services com logger.log em opera√ß√µes importantes
‚ñ° Controllers delegam para Services
‚ñ° Repositories usam JsonDbService
‚ñ° Nenhum console.log() no c√≥digo
‚ñ° updateBy sempre passado e persistido em updates
‚ñ° Testes (quando aplic√°vel)
‚ñ° Build compila sem erros: npm run build

================================================================================
15. QUICK REFERENCE - NOVO M√ìDULO
================================================================================

1. Criar pasta: modules/novo-modulo/
2. Criar estrutura:
   - novo-modulo.module.ts
   - novo-modulo.controller.ts
   - novo-modulo.service.ts
   - entities/novo-modulo.entity.ts
   - dto/create-novo-modulo.dto.ts
   - dto/update-novo-modulo.dto.ts
   - repositories/in-memory-novo-modulo.repository.ts

3. Copiar padr√£o de novo m√≥dulo existente (customers, equipments, stock)
4. Adaptar Entity, DTOs, Service, Repository
5. Registrar no app.module.ts
6. Build: npm run build
7. Testar endpoints

================================================================================

Vers√£o: 1.0
√öltima atualiza√ß√£o: 16/02/2026
Mantido por: Equipe Infyniq

Para d√∫vidas, consulte ARCHITECTURE.md ou BACKEND_SPEC.md

================================================================================
